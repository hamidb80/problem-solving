wrappers:
  parts:
  - sec: 
    - title: اجزا
    - body

  time:
  - sec.time-complexity.no-break:
    - title: پیچیدگی زمانی
    - body
  
  space:
  - sec.space-complexity.no-break:
    - title: پیچیدگی فضایی
    - body

  explain:
  - sec:
    - title: توضیح
    - body

  fn(name):
  - sec.$:
    - title: 
      - text: " تابع "
      - span.terminal.bold:
        - var: 0

    - body

  colored:
  - div.same-row:
    - empty.colorblock.$: 0
    - body

  par:
  - text: (
  - body
  - text: )


doc:
- title: 
    گزارش پروژه انتخاب بهینه سهام بورس

- sec#details:
  - title: مشخصات
  - lkv:
      - موضوع پروژه
      - سرمایه‌گذاری در بورس

      - نام و نام خانوادگی
      - حمیدرضا بلوری کاشانی

      - کد دانشجویی
      - 992164019
      
      - تاریخ
      - ترم اول 1401-1402
      
      - استاد
      - دکتر احسان خدنگی
      
      - دستیار استاد
      - فاطمه شوشتری زاده / امیررضا توکلی
      
      - درس
      - طراحی الگوریتم ( رشته مهندسی کامپیوتر )
      
      - دانشگاه
      - شاهد تهران

  - lkv:
    - رابط کاربری
    - دارد – تحت وب

    - زبان برنامه نویسی
    - link: 
        text: Nim
        url: https://nim-lang.org/

- sec.break#structure:
  - title: ساختار پروژه  

  - raw: |
      │   .gitignore
      │   knapsack.nimble
      │   readme.md
      │
      ├───build
      │   ├───report/
      │   └───app/
      │
      ├───docs/
      │   │   project-description.pdf
      │   │   report.yaml
      │   │
      │   └───assets/
      │
      ├───src/
      │   │   common.nim
      │   │   webapp.nim
      │   │   webapp.nims
      │   │
      │   └───knapsack/
      │           backtracking.nim
      │           dynamic.nim
      │           greedy.nim
      │
      └───tests/
              test.nim
              test.nims

  - lkv:
    - پوشه build
    - lkv:
      - پوشه app
      - فایل رابط کاربری
      
      - پوشه report
      - فایل گزارش

    - پوشه docs
    - فایل تعریف پروژه

    - پوشه src
    - lkv:
      - پوشه knapsack
      - حل مسئله با الگوریتم های مختلف
    
    - پوشه tests
    - چک کردن درستی برنامه

    - فایل knapsack.nimble
    - فایل پروژه زبان Nim
  
- sec.break#demo:
  - title: دموی رابط کاربری
  - span:
      همانطور که در قسمت قبل گفته شد، فایل رابط کاربری در پوشه
      build/web
      وجود دارد.
  
  - image.rounded: ./assets/demo.png

- sec.break#types:
  - title: ساختمان داده
  - image.rounded: ./assets/data_structure.png

- sec.break#analysis:
  - title: توضیح – تحلیل زمان و حافظه

  - sec#method#greedy:
    - title: الگوریتم حریصانه
    - image.rounded: ./assets/greedy_solve.png

    - parts:
      - list: 
        - colored.pink-red: 
            مرتب سازی آیتم ها
            براساس تابع مقایسه
            criteria
        
        - div:
          - colored.purple:
              پیمایش ترتیبی روی آیتم های مرتب شده

          - list:
            - colored.light-orange:
                اضافه کردن شرطی آن‌ها به لیست نتیجه  
          
    - time:
      - p:
          الگوریتم مرتب سازی زبان 
          Nim،
          الگوریتم
          merge sort
          مییباشد.
          تابع داده شده
          criteria 
          دو ورودی از نوع آیتم گرفته و آن ها را باهم مقایسه میکند.

      - formula: |
          O(T(n)) = O(mergeSort(n) × O(criterial(2))) + n×O(listAppend)
          = O(n.log(n) × 1) + n×O(1) = 
          = O(n.log(n))

    - space:
      - p:
          برای مرتب سازی به فضایی به اندازه آرایه ورودی نیاز داریم.
          برای انتخاب نیز در بدترین حالت ممکن، همه آیتم هارا انتخاب میکنیم.

      - formula: |
          O(S(n)) = O(mergeSort(n)) + O(select(n))
          = O(n) + O(n)
          = O(n)

  - sec#method#dynamic.break:
    - title: الگوریتم برنامه نویسی پویا

    - explain:
      - span:
          این  الگوریتم برای جلوگیری از زیاد شدن ستون‌ها جدول،
          ابتدا با تابع 
          determine
          .مقادیر مورد نیاز برای هر سطر را پیدا می‌کند
          بعد از اولین سطر تا آخرین، شروع به پرکردن مقادیر می‌کند
          در کنار جدول سود ها، یک جدول ایجاد کرده که انتخاب های خود را نگه می‌دارد

      - p:
          مثال برای الگوریتم ها، با آیتم های زیر و با حداکثر وزن 30 فرض شده
      
      - list:
        - سود 50 با وزن 5
        - سود 60 با وزن 10
        - سود 140 با وزن 20 
      
      - raw: |
          ┌──────────────┬───┬────┬────┬─────┐
          │ item/cap     │ 0 │ 10 │ 20 │ 30  │
          ├──────────────┼───┼────┼────┼─────┤
          │ #0 $50/5Kg   │ 0 │ 50 │ 50 │ 50  │
          ├──────────────┼───┼────┼────┼─────┤
          │ #1 $60/10Kg  │   │ 60 │    │ 110 │
          ├──────────────┼───┼────┼────┼─────┤
          │ #2 $140/20Kg │   │    │    │ 200 │
          └──────────────┴───┴────┴────┴─────┘

          ┌────────────────────────┬────────┬──────────────┬─────────┬───────────────┐
          │ item/(selected ->next) │ 0      │ 10           │ 20      │ 30            │
          ├────────────────────────┼────────┼──────────────┼─────────┼───────────────┤
          │ #0 $50/5Kg             │ no ->_ │ yes ->_      │ yes ->_ │ yes ->_       │
          ├────────────────────────┼────────┼──────────────┼─────────┼───────────────┤
          │ #1 $60/10Kg            │        │ yes ->(0, 0) │         │ yes ->(0, 20) │
          ├────────────────────────┼────────┼──────────────┼─────────┼───────────────┤
          │ #2 $140/20Kg           │        │              │         │ yes ->(1, 10) │
          └────────────────────────┴────────┴──────────────┴─────────┴───────────────┘

      - span:
          این الگوریتم از اولین (بالاترین) سطر شروع کرده تا به سطر آخر برسد،
          که جواب در ستون آخر سطر آخر قرار دارد.

    - fn(solve).break:
      - image.rounded: ./assets/dynamic_solve.png

      - parts:
        - list:
          - colored.light-orange: 
              پیدا کردن ستون های مورد نیاز برای هر سطر
        
          - colored.pink-red: 
              پر کردن سلول های مورد نیاز در جدول

          - colored.light-green:
              جمع آوری بهترین انتخاب ها 

      - time:
        - formula: |
            O(T(n)) 
            = 2×O(1) + O(determine(n)) + n×w×O(solveImpl(n)) + O(extractSelections(n))
            = O(1) + O(2^n) + n×w×O(1) + O(n)
            = O(2^n) + O(n×w)
        
      - space:
        - formula: |
            O(S(n)) = O(determine(n)) + O(extractSelections(n))
            = ...

    - fn(solveImpl).break:
      - image.rounded: ./assets/dynamic_solveImpl.png
        
      - time:
        - text:
            عملیات های خواندن یک 
            index
            از آرایه
        
        - par:
          - empty.colorblock.light-orange: 0

        - text: 
            ، و خواندن و نوشتن اطلاعات از 
            Hash Table
        
        - par:
          - empty.colorblock.light-green: 0
        
        - text:
            همگی در یک زمان ثابت انجام میشوند.
            بقیه عملیات ها هم جمع و 
            and
            هستند که آن ها هم در زمان ثابت انجام میشوند.
        
        - formula: O(1)
        
      - space:
        - p:
           این تابع بازگشتی نیست
           و فقط چند متغیر با اندازه ثابت
           بدون توجه به اندازه ورودی تعریف میکند

        - formula: O(1)

    - fn(extractSelections).break:
      - image.rounded: ./assets/dynamic_extractSelections.png
    
      - time:
        - text:
            عملیات های خواندن از یک 
            Hash Table
        
        - par:
          - empty.colorblock.pink-red: 0

        - text:
            و خواندن یک 
            index
            از آرایه

        - par:
          - empty.colorblock.light-orange: 0

        - text:
            و اضافه کردن به آرایه

        - par:
          - empty.colorblock.light-green: 0

        - text:
            همگی در زمان ثابت اجرا میشوند.
            این حقله به تعداد آیتم ها تکرار میشود.

        - formula: |
            O(T(n)) = n×O(1) = O(n)

      - space:
        - text:
            این تابع فقط یک متغیر با اندازه یکسان به نام
            cursor 
            تعریف میکند.
            همچنین آیتم های انتخاب شده را در متغیر نتیجه
            (result)
            میریزد که با توجه به اینکه در بدترین حالت همه آیتم ها انتخاب میشوند،
            میتواند طولی به اندازه
            n
            داشته باشد.

        - formula: |
            O(S(n)) = O(1) + O(n) = O(n)

    - fn(determine).break:
      - image.rounded: ./assets/dynamic_determine.png

      - time:
        - formula: |
            O(T(n)) = O(n) + O(determineImpl(n))
            = O(n) + O(2^n)
            = O(2^n)
        
      - space:
        - formula: |
            O(S(n)) = O(n) + O(determineImpl(n))
            = O(n) + O(n)
            = O(n)

    - fn(determineImpl).break:
      - image.rounded: ./assets/dynamic_determineImpl.png

      - time:
        - formula:
            O(T(n)) = 2×O(T(n-1)) + O(1) = O(2^n)
        
      - space:
        - text:
            یک تابع بازگشتی است که دو متغیر ثابت بدون توجه به اندازه ورودی تعریف میکند.
            با توجه به اینکه طول شاخه بازگشت 
            n
            است، پس

        - formula: |
            O(S(n)) = n×O(1) = O(n)

  - sec#method#backtracking.break:
    - title: الگوریتم عقبگرد
    
    - explain:
      - p:
          الگوریتم عثبگرد به پیمایش
          DFS
          و ذخیره کردن بهترین نتیجه،
          با استفاده تشخیص امیدبخش بودن یا نبودن
          (isPromising)
          شاخه مورد نظر، میتواند در بهبود سرعت عملکرد چشمگیری داشته باشد.

      - p:
          نتیجه زیر برای ورودی هایی که در تعریف پروژه آمده،
          توسط الگوریتم عقبگرد تولید شده.

          علامت 
          ✘
          به معنی شاخه های حذف شده است.

      - raw: |
          └─ 0 غزر ($750000/1030063)
            └─ 1 شاروم ($1700000/17736990)
                └─ 1 ولساپا ($560000/6012037)
                  └─ 1 دارایکم ($578000/11800530)
                      └─ 1 سیتا ($114900/2500306)
                        └─ 1 شستا ($890000/23061070)
                            └─ 1 آبادا ($137000/4000520)
                              └─ 1 آریا ($635568/19040100)
                                  └─ 1 کالا ($95000/3066057) 
                                    └─ 1 نوری ($240000/15011070)
                                        └─ 0 پیزد ($41000/5090040)
                                          └─ 1 برکت ($117000/14700090)
                                          └─ 0 برکت ($117000/14700090)
                                    └─ 0 نوری ($240000/15011070)
                                        └─ 0 پیزد ($41000/5090040) ✘
                                  └─ 0 کالا ($95000/3066057) ✘
                              └─ 0 آریا ($635568/19040100)
                                  └─ 1 کالا ($95000/3066057)
                                    └─ 1 نوری ($240000/15011070)
                                        └─ 1 پیزد ($41000/5090040)
                                          └─ 0 برکت ($117000/14700090)
                                        └─ 0 پیزد ($41000/5090040) ✘
                                    └─ 0 نوری ($240000/15011070) ✘
                                  └─ 0 کالا ($95000/3066057) ✘
                            └─ 0 آبادا ($137000/4000520) ✘
                        └─ 0 شستا ($890000/23061070)
                            └─ 1 آبادا ($137000/4000520)
                              └─ 1 آریا ($635568/19040100)
                                  └─ 1 کالا ($95000/3066057)
                                    └─ 1 نوری ($240000/15011070)
                                        └─ 0 پیزد ($41000/5090040) ✘
                                    └─ 0 نوری ($240000/15011070) ✘
                                  └─ 0 کالا ($95000/3066057) ✘
                              └─ 0 آریا ($635568/19040100) ✘
                            └─ 0 آبادا ($137000/4000520) ✘
                      └─ 0 سیتا ($114900/2500306) ✘
                  └─ 0 دارایکم ($578000/11800530) ✘
                └─ 0 ولساپا ($560000/6012037) ✘
            └─ 0 شاروم ($1700000/17736990) ✘
    - fn(solve).break: 
      - image.rounded: ./assets/back_solve.png

    - fn(solveImpl).break: 
      - image.rounded: ./assets/back_solveImpl.png

    - fn(isPromising).break:
      - image.rounded: ./assets/back_isPromising.png
    
    - fn(select).break: 
      - image.rounded: ./assets/back_select.png

- sec.break#run:
  - title:
      راهنمای اجرا و تولید نتیجه های مشاهده شده در این فایل

  - sec.tests:
    - p:
        چک کردن یکسان بودن خورجی الگوریتم های
        dynamic programming
        و 
        back tracking
        .

    - raw: nimble test

  - sec.debug:
    - p:
        دیدن خروجی تست الگوریتم های
        dynamic programming
        و 
        back tracking
        .

    - raw: nimble debug
    
  - sec.debug:
    - p:
        ساخت رابط کاربری در پوشه
        build/web.

    - raw: nimble web